#include "tools.h"

namespace tools
{

const double PI = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067;
// const double PI = 4.0*atan(1.0);

//------------------------------------------------------------------------------
// Uses Euclid's algorithm to obtain the Greatest Common Divisor (GCD); The GCD
// is the largest positive integer (of two non-zero integers) that divides the
// numbers WITHOUT a remainder E.g., GCD of 42 and 56 is 14.
//
//		42  =  3 x 14  =  3
//    --     -   --     -
//    56     4 x 14  =  4
//
// The GCD is useful in reducing fractions.
//------------------------------------------------------------------------------
int gcd(int a, int b)
{
	if(b==0) return a;              // base case; returns a when b equals 0
	else     return gcd(b, a % b);  // recursive call using generic arithmetic rules
}


//------------------------------------------------------------------------------
// Returns factorial of n if n is <25.  NOTE: While a factorial is algorithmically
// trivial to compute, the size of the result will be so large that the results
// will quickly run into overflow problems. E.g., 25! takes more than 64 bits of
// space when represented and a number.
//
// 12! appears to be safely stored as a 32 bit integer (20! for 64bit).
//------------------------------------------------------------------------------
int factorial(int n)
{
	if(n<13)
	{
		if(n==1 || n==0) return 1;
		return (factorial(n-1) * n);
	}
	else
	{
		cout << "ERROR::tools:factoral: To avoid overflow, only factorial less than 12 are permitted.\n";
		cout << "Sorry, this program must terminate.\n";
		exit(0);
	}
}




//------------------------------------------------------------------------------
// Approximate the factorial function with Sterling's formulas; fairly good
// approximation for larger values of "n"; The difference between the true
// factorial and the returned value can be between 7% and 8%. The approximation
// is very good for n>10 (error < .8%)
//
// Note: using Gosper's variant of the Sterling approximation
//------------------------------------------------------------------------------
double sterling_factorial(int n)
{
	if(n==1 || n==0) return 1;
	else if (n <= 125)
	{
		double x = sqrt( ((2*n)+(1/3))*PI ) * pow(n,n) * exp(-1*n);
		return x;
	}
	else if (n > 125 && n < 165)
	{
	   int x = n+1;
	   double result = (x-0.5)*log(x) - x + 0.5*log(2*PI) + 1.0/(12.0*x);
	   return exp(result);
	}
	else
	{
		cout << "ERROR::tools::sterling_factorial: n (" << n << ") out of bounds.\n";
		cout << "Sorry, Proteus must terminate.\n";
		exit(0);
	}

}


//------------------------------------------------------------------------------
// Returns a pseudo-random double precision number within the specified range
//------------------------------------------------------------------------------
double double_rand(double min, double max)
{
   //NOTE: RAND_MAX is a constant defined in <sctlib>. Its default value can vary
   //      between implementations, but it is guaranteed to be at least 32767


   //NOTE2: srand ( time(NULL) ) should NOT be called here; you call it once before
   //       using rand() and this seed will give a nice set of pseudo-random numbers.

   double num = ( double(rand()) / (double(RAND_MAX)+1.0) );  // random double within rage 0.0 to 1.0 (non-inclusive)

   if(min==0.0 && max==1.0)
   {
      return num;
   }
   else
   {
      num = min + num*(max - min);  // transform to the specified range; num*(max-min) = scale; +min = shift lower boundary to min
      return num;
   }
}


//------------------------------------------------------------------------------
// Returns a pseudorandom double precision number that follows a normal distribution
//
// PREREQUSITES: <math.h> for sqrt()
//------------------------------------------------------------------------------
double rand_gaussian(double mu, double sigma)
{
/* Normal (Gaussian) distributed pseudo-random number is generated by using the
 * Box-Muller transformation.  The transformation generates two uniformly distributed
 * variables and transforms them into two independently distributed normal variables.
 *
 * The function uses the the "polar" version of the Box-Muller transformation. This version
 * avoids making extra costly trigonometric function calls.
 *
 * Because the algorithm generates a pair of random variables, on is stored in case a second
 * call is made to this function; thereby saving a little computation. The other one is
 * returned.
 */

	bool available = false;   // flag indicates is a stored, and unused, random variable is available
	float stored_value = 1;   // stored value of unused random variable

	double u1, u2;            // a pair of independent and uniformly distributed variables within interval [-1, +1]; i.e., a uniform square
	double g1, g2;            // a pair of independent and Gaussian random variables
	double s;                 // s = (u1)^2 + (u2)^2; s must be
	double polar;             // required for polar transformation of variables u1 and u2

	if(!available)
	{
		do
		{
			u1 = 2.0 * ( double(rand())/double(RAND_MAX) ) - 1.0;
			u2 = 2.0 * ( double(rand())/double(RAND_MAX) ) - 1.0;
			s = (u1*u1) + (u2*u2);
			//NOTE: while condition check if s falls is in the open unit circle (0,1)
		}
		while ( s>=1.0  || s==0.0);   // i.e., if s=0 or s>=1 then values for u1 and u2 are thrown away and we re-sample u1 and u2
		polar = sqrt(-2.0*log(s)/s);  // required for transformation
		stored_value = u1*polar;      // store value for u1->g1
		available = true;             // set flag
	   g2 = u2*polar*sigma + mu;     // transform u2 -> g2
	   return g2;                    // combine with above line
	}
	else
	{
		available = false;             // we will be using the stared value to compute g1;
		g1 = stored_value*sigma + mu;  // transform stored value -> g1; Initialized value is irrelevant as this var only used after first use
		return g1;                     // combine with above line?
	}
}


//------------------------------------------------------------------------------
//  Sets size of vector and fills it with random integers sampled WITHOUT from
//  the interval (min,max)
//------------------------------------------------------------------------------
void int_rand_series(vector<int>* vec, int size, int min, int max)
{
	if(min < 0)
	{
		cout << "ERROR::tools::int_rand_series: min value can't be negative\n";
		cout << "Sorry, Proteus must terminate\n";
		exit(0);
	}
	if(size > (max-min))
	{
		cout << "ERROR::tools::int_rand_series: size of vec is too large\n";
		cout << "Sorry, Proteus must terminate\n";
		exit(0);
	}

	int num;
	vec->clear();
	vector<int>::iterator iter;
	srand(static_cast<unsigned int>(clock()));

	for(int i=0; i<size; i++)
	{
		num = (rand() % max);
		num = num + min;
		iter = find(vec->begin(), vec->end(), num);
      if (iter != vec->end()) {/* found it */ i--;   }
      else                    { vec->push_back(num); }
	}
}


//------------------------------------------------------------------------------
// returns the intersection of characters within two strings; chars are unique!
//------------------------------------------------------------------------------
string intersection(string a, string b)
{
   // perhaps put this in a tools.h?
   string intersection;
   for(unsigned int i=0; i<a.size(); i++)
   {
      for(unsigned int j=0; j<b.size(); j++)
      {
         if(a[i]==b[j]) {intersection = intersection + a[i];}
      }
   }
   intersection = unique_dna(intersection);
   return intersection;
}


//------------------------------------------------------------------------------
// returns the union of characters within two strings
//------------------------------------------------------------------------------
string my_union(string a, string b)
{
   // perhaps put this in a tools.h?
   // very simple now, but not so simple if states are codons
	// works for DNA (and AA with modification!) b/c states can be represented by single characters!
   string my_union = (a + b);
   my_union = unique_dna(my_union);
   //my_union = unique_aa(my_union); ???
   return my_union;
}

//------------------------------------------------------------------------------
// returns the union of characters within two strings
//------------------------------------------------------------------------------
string unique_dna(string str)
{
   // perhaps put this in a tools namespece?
   // will need one for AAs and Codons; might be a good choice of overriding/polymorphism?
   string new_string;
   //cout << "String from: " << str;
   if(str.find("A") != string::npos) {new_string = new_string+"A";}
   if(str.find("C") != string::npos) {new_string = new_string+"C";}
   if(str.find("G") != string::npos) {new_string = new_string+"G";}
   if(str.find("T") != string::npos) {new_string = new_string+"T";}
   //cout << " to: " << new_string << "\n";
   return new_string;
}


//------------------------------------------------------------------------------
// Computes mean of an vector of doubles
//------------------------------------------------------------------------------
double compute_mean(vector<double>* vec)
{
	/* Note this is a fast way to compute a mean if the data will not be adjusted
	 * in a way the requires recomputing the mean from time to time.  In cases where
	 * the data will be change, then using a object would provide some benefits in
	 * speed in the long run.
	 */

	double accumulate = 0;

	for(unsigned int i=0; i<vec->size(); i++)
	{
		accumulate += (*vec)[i];
	}
	//cout << "***  " << accumulate/vec->size() << " = " << accumulate << " / " << vec->size() << "\n";
	return accumulate/vec->size();
}


//------------------------------------------------------------------------------
// Computes standard deviation of values in a vector of double
//------------------------------------------------------------------------------
double compute_sd(vector<double>* vec)
{
   /*  To save a little on the computation I use the method that
    *  takes the mean of each squared-value and subtracts from that
    *  the squared-mean.  The cost of squaring is unavoidable, but it
    *  save a little by avoiding many subtractions.
    */

	vector<double> squared_vals;
	squared_vals.resize(vec->size());

	for(unsigned int i=0; i<vec->size(); i++)
	{
		squared_vals[i] = (*vec)[i] * (*vec)[i];
	}

	double mean_of_squaredvalues = tools::compute_mean(&squared_vals);
	double squared_mean = tools::compute_mean(vec);
	squared_mean = squared_mean*squared_mean;

	return sqrt(mean_of_squaredvalues - squared_mean);
}



//------------------------------------------------------------------------------
// Returns exact binomial for n < 13; and and approximation when n>=13.
//
// The approximation is based on a variant of Sterling's approximation to the
// factorial and is computed in a log transformed domain to avoid overflow
// due to the factorial when n>13
//------------------------------------------------------------------------------
double binomial(int n, double p, int k)
{
	if(n<13)
	{
		return ( factorial(n)/(factorial(k)*factorial(n-k)) ) * ( pow(p,k) * pow(1-p,n-k) );
	}
	else
	{
		double l1 = log_factorial(n);
		double l2 = log_factorial(k);
		double l3 = log_factorial(n-k);
		return exp( l1-l2-l3 + k*log(p) + (n-k)*log(1-p) );
	}
}


//------------------------------------------------------------------------------
// Returns approximation to the binomial: typically use this when n is large (>50)
// and p is small (such that n*p < 10).
//------------------------------------------------------------------------------
double poisson_apprx_binomial(int n, double p, int k)
{
	// n = number of trials
	// k = number of successes
	// p = true prob of success
	// lambda = n*p

	/*
	 *                 e^(-lambda) x lambda^k
	 *  P(k) approx=  ________________________
	 *                             k!
	 *
	 */

	double lambda = n*p;
	double k_fact;

	if(n<11) k_fact = factorial(k);
	else     k_fact = sterling_factorial(k);   //NOTE: This factorial will TANK when n>166-ish!!!

	return (exp(-1.0*lambda)*pow(lambda,k))/(k_fact);
}


//------------------------------------------------------------------------------
// Returns the height of the probability distribution at the value of x
// (not the probability of x, which is always zero for a single point)
//------------------------------------------------------------------------------
double normal_PDF(double x, double mean, double sigma)
{
	return (1.0/(sqrt(2.0*PI)*sigma)) * exp( -0.5*(  ((x-mean)*(x-mean)) / (sigma*sigma)  ) );

	//******TEMP truncate prior********
	/*
	double p = (1.0/(sqrt(2.0*PI)*sigma)) * exp( -0.5*(  ((x-mean)*(x-mean)) / (sigma*sigma)  ) );
	if (x < 0) return 0.0;
	else return p;
	*/
}


//------------------------------------------------------------------------------
// Returns probability of a uniform random variable x over the interval a to b
//------------------------------------------------------------------------------
double p_uniform(double x, double lower, double upper)
{
	if(lower > upper)
	{
		cout << "WARNING::tools::uniform: Swapped input values for lower and upper bounds because, as input, lower > upper\n";
		double temp = upper;
		upper = lower;
		lower = temp;
	}
	if( x<lower || x>upper) return 0;
	//else return (1.0 / (lower-upper));
	else return (1.0 / (upper-lower));
}


//------------------------------------------------------------------------------
// just print the contents to the screen
//------------------------------------------------------------------------------
void print_string_vector(vector<string> *my_vector)
{
   cout << "Contents of the string vector:\n";
   int size = my_vector->size();
   for(int i=0; i<size; i++)
   {
      cout << "\t" << i << ": " <<  (*my_vector)[i] << "\n";
   }
   cout << "\n";
}


//------------------------------------------------------------------------------
// Breaks text within "my_str" into a stream of tokens (space delimited) which
// are then stored as separate elements within a vector.
//------------------------------------------------------------------------------
void str_tok(string my_str, vector<string> *my_vector)
{
	string buffer;                 // create a string buffer
	stringstream ss(my_str);       // insert my_str into the "ss" stringstream
	my_vector->clear();            // vector now has size = 0
	while (ss >> buffer)
	{
	   my_vector->push_back(buffer); //store each individual characters/words in an element of "my_vector".
	}
}



//------------------------------------------------------------------------------
// a method for "find and replace" within a string
//------------------------------------------------------------------------------
void find_replace(string &str, const string &find_this, const string &replacement)
{
  size_t pos = 0;
  while((pos = str.find(find_this, pos)) != std::string::npos)
  {
     str.replace(pos, find_this.length(), replacement);
     pos += replacement.length();
  }
}

//------------------------------------------------------------------------------
// a method for finding all instances of a substring within a string and erasing it
//------------------------------------------------------------------------------
void find_erase(string &str, const string &find_this)
{
  size_t pos = 0;
  while( (pos = str.find(find_this, pos)) != std::string::npos )
  {
	  str.erase(pos, find_this.length());
  }
}

//------------------------------------------------------------------------------
// remove all white space from a string (AS YET UNTESTED!!!)
//------------------------------------------------------------------------------
void remove_whitespace(string &input)
{
   //cout << "remove_whitespace\n";
   int i=0;
   int size = input.size();
   while (i != (size))
   {
      if( isspace(input[i]) )
      {
         input.erase(i,1);
         size = input.size();
      }
      else {i++;}
   }
}


//------------------------------------------------------------------------------
// generic vector copy method; use to copy site likelihoods from likelihood
// engine to local vector
//------------------------------------------------------------------------------
void copy(vector<double>* copy , const vector<double>* primary)
{
   if( (*copy).size() == (*primary).size() )
   {
      for(unsigned int i=0; i<(*copy).size(); i++)
      {
         (*copy)[i] = (*primary)[i];
      }
   }
   else
   {
      cout << "ERROR::tools::copy:vector<double> sizes are not equal.\n";
   }
}


//------------------------------------------------------------------------------
// generic boolean vector copy method; use to copy optimize_this flags
//------------------------------------------------------------------------------
void copy(vector<bool>* copy , const vector<bool>* primary)
{
   if( (*copy).size() == (*primary).size() )
   {
      for(unsigned int i=0; i<(*copy).size(); i++)
      {
         (*copy)[i] = (*primary)[i];
      }
   }
   else
   {
      cout << "ERROR::tools::copy:vector<bool> sizes are not equal.\n";
   }
}


//------------------------------------------------------------------------------
// generic string vector copy method
//------------------------------------------------------------------------------
void copy(vector<string>* copy , const vector<string>* primary)
{
   if( (*copy).size() == (*primary).size() )
   {
      for(unsigned int i=0; i<(*copy).size(); i++)
      {
         (*copy)[i] = (*primary)[i];
      }
   }
   else
   {
      cout << "ERROR::tools::copy:vector<string> sizes are not equal.\n";
   }
}


//------------------------------------------------------------------------------
// "for loop" method for converting a string to all lowercase characters
//------------------------------------------------------------------------------
string string_tolower(string str)
{
	/* Notes:  1. Using a for loop with TWO initializations (i and length). This
	 *         keeps the scope of length as tight as possible (i.e., inside
	 *         the loop!).
	 *
	 *			  2. Avoid using the .length() function when testing the for loop condition
	 *			  saves looping over the str to determine the length (e.g., avoid something
	 *			  like this "for(unsigned int i=0;i<strToConvert.length();i++)".  Speed
	 *			  could be an issue with really big strings?
	 *
	 * WARNING: Using the "tolower" method should work for plain ASCII string, BUT, it
	 *           will NOT properly lower case Greek characters, or characters from other
	 *           alphabets!!! If there is no lower case equivalent the original character
	 *           is returned.
	 */

   for(std::size_t i = 0, length = str.length(); i != length; ++i)
   {
      str[i] = tolower(str[i]);
   }
   return str;
}

//------------------------------------------------------------------------------
// STL algorithm method for converting a string to all lower-case characters
//------------------------------------------------------------------------------
string STL_string_tolower(string str)
{
	/*  Note1: Still using "toupper"; see warning above about other alphabets
	 *
	 *  Note2: This method uses many STL calls; possibly more overhead than
	 *         above method based on the for loop, and considerable slower
	 *         for small strings ????
	 *
	 *  Note3:  str.begin()   // original string's beginning
     *          str.end()     // original string's end
     *          str.begin()   // where to write the new string?
     *          toupper       // unary operator
     *
     *  Note4: required includes
     * 			# include <algorithm>
     *  		# include <string>
     *   		# include <cstdlib>    // std::tolower
     *
     *  Note5: the use of toupper is ambiguous; there are two functions in std with the same name!!! How could this be?
     *         - I want to use the one that takes an int as an argument (but there may be other problems with this!!!)
	 */

	//std::transform(str.begin(), str.end(), str.begin(), ::tolower);  // undefined behavior???
	std::transform(str.begin(), str.end(), str.begin(), static_cast < int(*)(int) > (tolower));  //static cast corrects the undefined behaviour b/c it specifies the method that takes the int!
	return str;
}

//------------------------------------------------------------------------------
// "for loop" method for converting a string to all UPPERcase characters
//------------------------------------------------------------------------------
string string_toupper(string str)
{
	/* Notes:  1. Using a for loop with TWO initializations (i and length). This
	 *         keeps the scope of length as tight as possible (i.e., inside
	 *         the loop!).
	 *
	 *			  2. Avoid using the .length() function when testing the for loop condition
	 *			  saves looping over the str to determine the length (e.g., avoid something
	 *			  like this "for(unsigned int i=0;i<strToConvert.length();i++)".  Speed
	 *			  could be an issue with really big strings?
	 *
	 * WARNING: Using the "toupper" method should work for plain ASCII string, BUT, it
	 *           will NOT properly upper case Greek characters, or characters from other
	 *           alphabets!!! If there is no upper case equivalent the original character
	 *           is returned.
	 */

   for(std::size_t i = 0, length = str.length(); i != length; ++i)
   {
      str[i] = toupper(str[i]);
   }
   return str;
}


//------------------------------------------------------------------------------
// returns a tring holding the current date in format: day/month/year
//------------------------------------------------------------------------------
string get_current_date()
{
   time_t rawtime = time(0);

   struct tm* timeinfo;
   char buffer[80];

   time (&rawtime);
   timeinfo = localtime(&rawtime);

   strftime(buffer,80,"%d/%m/%Y",timeinfo);
   return buffer;

   //tm* ltm = localtime(&rawtime);
   //string current_date = ltm->tm_mday + "/" + ltm->tm_mon + "/" + ltm->tm_year;
   //return current_date;
}


//------------------------------------------------------------------------------
// returns double
//------------------------------------------------------------------------------
double str_to_double(string str)
{
   double result;
   istringstream ss(str);
   if( !(ss >> result) ) result = 0;
   return result;
}


//------------------------------------------------------------------------------
// returns int
//------------------------------------------------------------------------------
int str_to_int(string str)
{
   int result;
   istringstream ss(str);
   if( !(ss >> result) ) result = 0;
   return result;
}


//------------------------------------------------------------------------------
// returns string; if conversion fails it returns "fail"
//
// NOTE: C++11 now has std::to_string
//------------------------------------------------------------------------------
string int_to_str(int number)
{
   string result;
   ostringstream ss;
   ss << number;
   result = ss.str();
   if(ss.fail()) return "fail";
   return result;
}



//------------------------------------------------------------------------------
// PRIVATE: parse keyword from keyword(#,#,#)
//------------------------------------------------------------------------------
string parse_keyword(string input)
{
   int pos1 = 0;
   int pos2;

   pos2 = input.find_first_of("(");           // == -1 if cmd has no "("

   if(pos2==-1)                               // if -1, then get length of cmd
   {
      pos2 = input.length();                  // if there are no arguments, the line length will do
   }
   string clip(&input[pos1], &input[pos2]);
   return clip;
}


//------------------------------------------------------------------------------
// PRIVATE: parse arguments from between () and load them into args vector
//------------------------------------------------------------------------------
void parse_args(string input, vector<string> *my_vector)
{
   int pos1;
   int pos2;
   string str;

   pos1 = input.find_first_of("(");         // == -1 if str has no "("
   pos2 = input.find_first_of(")");         // == -1 if str has no ")"

   if(pos1==-1 || pos2==-1)
   {
      cout << "ERROR::tools::parse_args: missing or unmatched parentheses.\n";
      cout << "Sorry. Proteus must terminate.\n";
      exit(1);
   }
   else
   {
      string my_args(&input[pos1+1], &input[pos2]);     // parse the cmd from the line
      str = my_args;
   }

   //NOTE: Here I assume that all commas have been replaced and spaces are sufficient for
   //      tokenizing the input line.

   // Tokenize the string and store the tokens in a vector<string>; NOTE: size of this
   // vector will be ZERO if there are only spaces between "(" and ")"
   tools::str_tok(str, my_vector);

   /*
   //show what we got...
   for(unsigned int i=0; i<(*my_vector).size(); i++)  cout << "\telement[" << i << "] = " << (*my_vector)[i] << "\n";
   cout << "\tsize of args vector = " << (*my_vector).size() << "\n\n";
   */
}


//------------------------------------------------------------------------------
// PRIVATE: given a vector with  a "-" at index, it expands series; e.g., start
//          with 1-4 in a single element of the vector and end with 1, 2, 3, 4 in
//          separate elements of the array.
//------------------------------------------------------------------------------
void expand_series(vector<string> *a_vec)
{
   cout << "tools::expand_series: vec2 looks like this at start: ";
   cout << (*a_vec)[0] << "\n";


   int pos1, pos2;
   string holder;
   string series = (*a_vec)[0];
   vector<string> series_vec;
   vector<string> expanded_vec;

   // get first and last int of the series
   pos1 = series.find_first_not_of(" \t\r\n");
   pos2 = series.find_first_of("-");     //OLD: pos2 = series.find_first_not_of("-")+1;  // b/c the clip below is NOT inclusive of last position, need to add 1
   string clip1(&series[pos1], &series[pos2]);
   int first_int = tools::str_to_int(clip1);
   //cout << "d_collection::series_vec: pos1 = " << pos1 << "and pos2 = " << pos2 << "\n";
   //cout << "d_collection::series_vec: first_int = " << first_int << "\n";

   pos1 = pos2+1;
   pos2 = series.find_last_not_of(" \t\r\n")+1;   // b/c the clip below is NOT inclusive of last position, need to add 1
   string clip2(&series[pos1], &series[pos2]);
   int last_int = tools::str_to_int(clip2);
   //cout << "d_collection::series_vec: pos1 = " << pos1 << "and pos2 = " << pos2 << "\n";
   //cout << "d_collection::series_vec: last_int = " << last_int << "\n";

   // loop over the range of ints and store them in a vector as strings
   for(int i=first_int; i<last_int+1; ++i)
   {
      holder = tools::int_to_str(i); //C++11 now has std::to_string
      series_vec.push_back(holder);
   }

   // copy expanded vector to *a_vec
   (*a_vec).clear();
   (*a_vec).resize(series_vec.size());
   tools::copy(a_vec, &series_vec);

   cout << "d_collection::expand_series: vec2 now looks like this: ";
   for(unsigned int i=0; i<(*a_vec).size(); i++)
   {
      cout << (*a_vec)[i] << " ";
   }
   cout << "\n";
}


//------------------------------------------------------------------------------
// PRIVATE:  if string=="false", return 0; if string=="true", return 1; any
//           other string, return -1.  Returning an int in stead of a bool
//           to allow -1 to indicate failure.
//------------------------------------------------------------------------------
int string_to_bool(string str)
{
   if     (str == "true")  return 1;
   else if(str == "false") return 0;
   else  return -1;
}


//------------------------------------------------------------------------------
// To avoid factorial you can work in the log domain; hence this function returns
// the log(n!) rather than n!  Working the the log domain you can compute binomial
// probabilities using this function and avoid the overflow issues associates with
// the factorial
//
// Note: for n < 255 this function returns pre-computed log(n!) to save some
// computation
//------------------------------------------------------------------------------
double log_factorial(int n)
{
	if(n<0)
	{
		cout << "ERROR::tools::log_factoral: negative n (" << n << ") is not permitted.\n";
		cout << "Sorry, this program must terminate.\n";
		exit(0);
	}
	else if(n > 254)
	{
		int x = n+1;
		return (x-0.5)*log(x) - x + 0.5*log(2*PI) + 1.0/(12.0*x);
	}
	else
	{
		double logfact[255] =
			{
				0.000000000000000,
				0.000000000000000,
				0.693147180559945,
				1.791759469228050,
				3.178053830347940,
				4.787491742782040,
				6.579251212010100,
				8.525161361065410,
				10.604602902745200,
				12.801827480081400,
				15.104412573075500,
				17.502307845873800,
				19.987214495661800,
				22.552163853123400,
				25.191221182738600,
				27.899271383840800,
				30.671860106080600,
				33.505073450136800,
				36.395445208033000,
				39.339884187199400,
				42.335616460753400,
				45.380138898476900,
				48.471181351835200,
				51.606675567764300,
				54.784729398112300,
				58.003605222980500,
				61.261701761002000,
				64.557538627006300,
				67.889743137181500,
				71.257038967168000,
				74.658236348830100,
				78.092223553315300,
				81.557959456115000,
				85.054467017581500,
				88.580827542197600,
				92.136175603687000,
				95.719694542143200,
				99.330612454787400,
				102.968198614513000,
				106.631760260643000,
				110.320639714757000,
				114.034211781461000,
				117.771881399745000,
				121.533081515438000,
				125.317271149356000,
				129.123933639127000,
				132.952575035616000,
				136.802722637326000,
				140.673923648234000,
				144.565743946344000,
				148.477766951773000,
				152.409592584497000,
				156.360836303078000,
				160.331128216630000,
				164.320112263195000,
				168.327445448427000,
				172.352797139162000,
				176.395848406997000,
				180.456291417543000,
				184.533828861449000,
				188.628173423671000,
				192.739047287844000,
				196.866181672889000,
				201.009316399281000,
				205.168199482641000,
				209.342586752536000,
				213.532241494563000,
				217.736934113954000,
				221.956441819130000,
				226.190548323727000,
				230.439043565776000,
				234.701723442818000,
				238.978389561834000,
				243.268849002982000,
				247.572914096186000,
				251.890402209723000,
				256.221135550009000,
				260.564940971863000,
				264.921649798552000,
				269.291097651019000,
				273.673124285693000,
				278.067573440366000,
				282.474292687630000,
				286.893133295426000,
				291.323950094270000,
				295.766601350760000,
				300.220948647014000,
				304.686856765668000,
				309.164193580146000,
				313.652829949878000,
				318.152639620209000,
				322.663499126726000,
				327.185287703775000,
				331.717887196928000,
				336.261181979198000,
				340.815058870798000,
				345.379407062266000,
				349.954118040770000,
				354.539085519440000,
				359.134205369575000,
				363.739375555563000,
				368.354496072404000,
				372.979468885689000,
				377.614197873918000,
				382.258588773060000,
				386.912549123217000,
				391.575988217329000,
				396.248817051791000,
				400.930948278915000,
				405.622296161144000,
				410.322776526937000,
				415.032306728249000,
				419.750805599544000,
				424.478193418257000,
				429.214391866651000,
				433.959323995014000,
				438.712914186121000,
				443.475088120918000,
				448.245772745384000,
				453.024896238496000,
				457.812387981278000,
				462.608178526874000,
				467.412199571608000,
				472.224383926980000,
				477.044665492585000,
				481.872979229887000,
				486.709261136839000,
				491.553448223298000,
				496.405478487217000,
				501.265290891579000,
				506.132825342034000,
				511.008022665236000,
				515.890824587822000,
				520.781173716044000,
				525.679013515995000,
				530.584288294433000,
				535.496943180169000,
				540.416924105997000,
				545.344177791154000,
				550.278651724285000,
				555.220294146894000,
				560.169054037273000,
				565.124881094874000,
				570.087725725134000,
				575.057539024710000,
				580.034272767130000,
				585.017879388839000,
				590.008311975617000,
				595.005524249382000,
				600.009470555327000,
				605.020105849423000,
				610.037385686238000,
				615.061266207084000,
				620.091704128477000,
				625.128656730891000,
				630.172081847810000,
				635.221937855059000,
				640.278183660408000,
				645.340778693435000,
				650.409682895655000,
				655.484856710889000,
				660.566261075873000,
				665.653857411105000,
				670.747607611912000,
				675.847474039736000,
				680.953419513637000,
				686.065407301994000,
				691.183401114410000,
				696.307365093814000,
				701.437263808737000,
				706.573062245787000,
				711.714725802289000,
				716.862220279103000,
				722.015511873601000,
				727.174567172815000,
				732.339353146739000,
				737.509837141777000,
				742.685986874351000,
				747.867770424643000,
				753.055156230484000,
				758.248113081374000,
				763.446610112640000,
				768.650616799717000,
				773.860102952558000,
				779.075038710167000,
				784.295394535245000,
				789.521141208958000,
				794.752249825813000,
				799.988691788643000,
				805.230438803703000,
				810.477462875863000,
				815.729736303910000,
				820.987231675937000,
				826.249921864842000,
				831.517780023906000,
				836.790779582469000,
				842.068894241700000,
				847.352097970438000,
				852.640365001133000,
				857.933669825857000,
				863.231987192405000,
				868.535292100464000,
				873.843559797865000,
				879.156765776907000,
				884.474885770751000,
				889.797895749890000,
				895.125771918679000,
				900.458490711945000,
				905.796028791646000,
				911.138363043611000,
				916.485470574328000,
				921.837328707804000,
				927.193914982476000,
				932.555207148186000,
				937.921183163208000,
				943.291821191335000,
				948.667099599019000,
				954.046996952560000,
				959.431492015349000,
				964.820563745165000,
				970.214191291518000,
				975.612353993036000,
				981.015031374908000,
				986.422203146368000,
				991.833849198223000,
				997.249949600427000,
				1002.670484599700000,
				1008.095434617180000,
				1013.524780246130000,
				1018.958502249690000,
				1024.396581558610000,
				1029.838999269130000,
				1035.285736640800000,
				1040.736775094360000,
				1046.192096209720000,
				1051.651681723860000,
				1057.115513528890000,
				1062.583573670030000,
				1068.055844343700000,
				1073.532307895630000,
				1079.012946818970000,
				1084.497743752460000,
				1089.986681478620000,
				1095.479742921960000,
				1100.976911147250000,
				1106.478169357800000,
				1111.983500893730000,
				1117.492889230360000,
				1123.006317976520000,
				1128.523770872990000,
				1134.045231790850000,
				1139.570684729980000,
				1145.100113817490000,
				1150.633503306220000,
				1156.170837573240000,
			};
		return logfact[n];
	}
}


}//end tools namespace

